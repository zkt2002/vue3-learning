<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>代理Map,Set</title>
</head>

<body></body>

<script>
  const mutableInstrumentations = {
    add(key) {
      // this 仍然指向的是代理对象，通过 raw 属性获取原始数据对象
      const target = this.raw
      // 通过原始数据对象执行 add 方法添加具体的值，
      // 注意，这里不再需要 .bind 了，因为是直接通过 target 调用并执行的
      const res = target.add(key)
      // 调用 trigger 函数触发响应，并指定操作类型为 ADD
      trigger(target, key, 'ADD')
      // 返回操作结果
      return res
    }
    ,
    set(key, value) {
      const target = this.raw
      const had = target.has(key)

      const oldValue = target.get(key)
      // 获取原始数据，由于 value 本身可能已经是原始数据，所以此时value.raw 不存在，则直接使用 value
      const rawValue = value.raw || value
      target.set(key, rawValue)

      if (!had) {
        trigger(target, key, 'ADD')
      } else if (oldValue !== value || (oldValue === oldValue && value === value)) {
        trigger(target, key, 'SET')
      }
    },
    delete(key) {
      const target = this.raw
      const hadKey = target.has(key)
      const res = target.delete(key)
      // 当要删除的元素确实存在时，才触发响应
      if (hadKey) {
        trigger(target, key, 'DELETE')
      }
      return res
    },
    get(key) {
      // 获取原始对象
      const target = this.raw
      // 判断读取的 key 是否存在
      const had = target.has(key)
      // 追踪依赖，建立响应联系
      track(target, key)
      // 如果存在，则返回结果。这里要注意的是，如果得到的结果 res 仍然是可代理
      // 的数据，则要返回使用 reactive 包装后的响应式数据
      if (had) {
        const res = target.get(key)
        return typeof res === 'object' ? reactive(res) : res
      }
    },
    forEach(callback, thisArg) {
      // wrap 函数用来把可代理的值转换为响应式数据
      const wrap = (val) => typeof val === 'object' ?
        reactive(val) : val
      const target = this.raw
      track(target, ITERATE_KEY)
      // 通过 target 调用原始 forEach 方法进行遍历
      target.forEach((v, k) => {
        // 手动调用 callback，用 wrap 函数包裹 value 和 key 后再传给
        // callback，这样就实现了深响应
        callback.call(thisArg, wrap(v), wrap(k), this)
      })
    },
    [Symbol.iterator]: iterationMethod,
    entries: iterationMethod,
    values: valuesIterationMethod,
    keys: keysIterationMethod
  }
  function createReactive(obj, isShallow = false, isReadonly =
    false) {
    return new Proxy(obj, {
      get(target, key, receiver) {
        // 如果读取的是 raw 属性，则返回原始数据对象 target
        if (key === 'raw') return target
        if (key === 'size') {
          track(target, ITERATE_KEY)
          return Reflect.get(target, key, target)
        }
        // 返回定义在 mutableInstrumentations 对象下的方法
        return mutableInstrumentations[key]
      }
    })
  }

  function trigger(target, key, type, newVal) {
    console.log('trigger', key)
    const depsMap = bucket.get(target)
    if (!depsMap) return
    const effects = depsMap.get(key)

    const effectsToRun = new Set()
    effects && effects.forEach(effectFn => {
      if (effectFn !== activeEffect) {
        effectsToRun.add(effectFn)
      }
    })

    if (
      type === 'ADD' || type === 'DELETE' ||
      // 如果操作类型是 SET，并且目标对象是 Map 类型的数据，
      // 也应该触发那些与 ITERATE_KEY 相关联的副作用函数重新执行
      (
        type === 'SET' &&
        Object.prototype.toString.call(target) === '[object Map]'
      )
    ) {
      const iterateEffects = depsMap.get(ITERATE_KEY)
      iterateEffects && iterateEffects.forEach(effectFn => {
        if (effectFn !== activeEffect) {
          effectsToRun.add(effectFn)
        }
      })
    }

    if (
      // 操作类型为 ADD 或 DELETE
      (type === 'ADD' || type === 'DELETE') &&
      // 并且是 Map 类型的数据
      Object.prototype.toString.call(target) === '[object Map]'
    ) {
      // 则取出那些与 MAP_KEY_ITERATE_KEY 相关联的副作用函数并执行
      const iterateEffects = depsMap.get(MAP_KEY_ITERATE_KEY)
      iterateEffects && iterateEffects.forEach(effectFn => {
        if (effectFn !== activeEffect) {
          effectsToRun.add(effectFn)
        }
      })
    }


    // 省略部分内容

    effectsToRun.forEach(effectFn => {
      if (effectFn.options.scheduler) {
        effectFn.options.scheduler(effectFn)
      } else {
        effectFn()
      }
    })
  }

  // 抽离为独立的函数，便于复用
  function iterationMethod() {
    const target = this.raw
    const itr = target[Symbol.iterator]()

    const wrap = (val) => typeof val === 'object' ? reactive(val)
      : val

    track(target, ITERATE_KEY)

    return {
      next() {
        const { value, done } = itr.next()
        return {
          value: value ? [wrap(value[0]), wrap(value[1])] : value,
          done
        }
      },
      // 实现可迭代协议
      [Symbol.iterator]() {
        return this
      }
    }
  }

  function valuesIterationMethod() {
    // 获取原始数据对象 target
    const target = this.raw
    // 通过 target.values 获取原始迭代器方法
    const itr = target.values()

    const wrap = (val) => typeof val === 'object' ? reactive(val)
      : val

    track(target, ITERATE_KEY)

    // 将其返回
    return {
      next() {
        const { value, done } = itr.next()
        return {
          // value 是值，而非键值对，所以只需要包裹 value 即可
          value: wrap(value),
          done
        }
      },
      [Symbol.iterator]() {
        return this
      }
    }
  }

  const MAP_KEY_ITERATE_KEY = Symbol()

  function keysIterationMethod() {
    // 获取原始数据对象 target
    const target = this.raw
    // 获取原始迭代器方法
    const itr = target.keys()

    const wrap = (val) => typeof val === 'object' ? reactive(val)
      : val

    // 调用 track 函数追踪依赖，在副作用函数与 MAP_KEY_ITERATE_KEY 之间建立响应联系
    track(target, MAP_KEY_ITERATE_KEY)

    // 将其返回
    return {
      next() {
        const { value, done } = itr.next()
        return {
          value: wrap(value),
          done
        }
      },
      [Symbol.iterator]() {
        return this
      }
    }
  }

  const m = new Map([['a', 1], ['b', 2]])
  console.log(m, m[Symbol.iterator] === m.entries);
  console.log(m.entries(), m[Symbol.iterator]());

</script>

</html>
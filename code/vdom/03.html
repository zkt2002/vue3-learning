<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>简单diff</title>
</head>

<body></body>

<script>
  function patchChildren(n1, n2, container) {
    if (typeof n2.children === 'string') {
      // 省略部分代码
    } else if (Array.isArray(n2.children)) {
      const oldChildren = n1.children
      const newChildren = n2.children

      let lastIndex = 0
      for (let i = 0; i < newChildren.length; i++) {
        const newVNode = newChildren[i]
        let j = 0
        let find = false
        for (j; j < oldChildren.length; j++) {
          const oldVNode = oldChildren[j]
          if (newVNode.key === oldVNode.key) {
            find = true
            patch(oldVNode, newVNode, container)
            if (j < lastIndex) {
              // 代码运行到这里，说明 newVNode 对应的真实 DOM 需要移动
              // 先获取 newVNode 的前一个 vnode，即 prevVNode
              const prevVNode = newChildren[i - 1]
              // 如果 prevVNode 不存在，则说明当前 newVNode 是第一个节点，它不需要移动
              if (prevVNode) {
                // 由于我们要将 newVNode 对应的真实 DOM 移动到prevVNode 所对应真实 DOM 后面，
                // 所以我们需要获取 prevVNode 所对应真实 DOM 的下一个兄弟节点，并将其作为锚点
                const anchor = prevVNode.el.nextSibling
                // 调用 insert 方法将 newVNode 对应的真实 DOM 插入到锚点元素前面，
                // 也就是 prevVNode 对应真实 DOM 的后面
                insert(newVNode.el, container, anchor)
              }
            } else {
              lastIndex = j
            }
            break
          }
        }

        // 如果代码运行到这里，find 仍然为 false，
        // 说明当前 newVNode 没有在旧的一组子节点中找到可复用的节点
        // 也就是说，当前 newVNode 是新增节点，需要挂载
        if (!find) {
          const prevVNode = newChildren[i - 1]
          let anchor = null
          if (prevVNode) {
            // 如果有前一个 vnode 节点，则使用它的下一个兄弟节点作为锚点元素
            anchor = prevVNode.el.nextSibling
          } else {
            // 如果没有前一个 vnode 节点，说明即将挂载的新节点是第一个子节点
            // 这时我们使用容器元素的 firstChild 作为锚点
            anchor = container.firstChild
          }
          patch(null, newVNode.el, container, anchor)
        }

        // 上一步的更新操作完成后
        // 遍历旧的一组子节点
        for (let i = 0; i < oldChildren.length; i++) {
          const oldVNode = oldChildren[i]
          // 拿旧子节点 oldVNode 去新的一组子节点中寻找具有相同 key 值的节点
          const has = newChildren.find(
            vnode => vnode.key === oldVNode.key
          )
          if (!has) {
            // 如果没有找到具有相同 key 值的节点，则说明需要删除该节点
            // 调用 unmount 函数将其卸载
            unmount(oldVNode)
          }
        }
      }
    } else {
      // 省略部分代码
    }
  }

  const renderer = createRenderer({
    // 省略部分代码

    insert(el, parent, anchor = null) {
      // insertBefore 需要锚点元素 anchor
      parent.insertBefore(el, anchor)
    }

    // 省略部分代码
  })

  // patch 函数需要接收第四个参数，即锚点元素
  function patch(n1, n2, container, anchor) {
    // 省略部分代码

    if (typeof type === 'string') {
      if (!n1) {
        // 挂载时将锚点元素作为第三个参数传递给 mountElement 函数
        mountElement(n2, container, anchor)
      } else {
        patchElement(n1, n2)
      }
    } else if (type === Text) {
      // 省略部分代码
    } else if (type === Fragment) {
      // 省略部分代码
    }
  }

  // mountElement 函数需要增加第三个参数，即锚点元素
  function mountElement(vnode, container, anchor) {
    // 省略部分代码

    // 在插入节点时，将锚点元素透传给 insert 函数
    insert(el, container, anchor)
  }
</script>

</html>